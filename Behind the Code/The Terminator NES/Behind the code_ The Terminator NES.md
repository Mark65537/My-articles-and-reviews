# **Behind the code: THE TERMINATOR**

## **Introduction**

This is The Terminator for The NES - a game released in December 1992 - 8 years after the film on which it is based. The gameplay is rather outdated for an NES title released on the eve of 1993. The NES itself was in its twilight years, and games like Super Spy Hunter, Darkwing Duck, Little Samson, Felix the Cat, or Bucky O’Hare perhaps best represented what the system’s hardware could do as it reached its ten year anniversary. Sunsoft had been working on a Terminator game at one point in time but lost the license during development. That game would be adapted into a different title and released in 1990. The subject of this video comes courtesy of Vancouver BC-based developer Radical Entertainment. The company was founded in September of 1991 and released two NES games just over one year later: The Adventures of Rocky and Bullwinkle, and our current focus, The Terminator. Speaking of Behind the Code and The Terminator, we see instances of 6502 Assembly code in the film.

![image1](images\image10.png)

Why would the Terminator be reviewing unassembled code while chasing Sarah Connor? Well the question you should be asking is, “if he runs a multitasking OS, why wouldn’t he?” Let’s get into the game and especially its play control. There are plenty of oddities to cover for this one.

## **Why is the maximum number of lives in game 6?**

We’ll start with a quirk regarding spare lives. You receive an extra life for scoring 50,000 points, however you are limited to a maximum of 6. Was this by design? Terminator doesn’t store the lives remaining as a number in RAM. It stores the Tile ID for the graphics representing that number. So if you have 2 lives left, RAM holds a value of $1B - this tile here. The numbers 7, 8, and 9 begin here - at a value of $20 hex - represented on the next row. There is code that limits the extra lives not to the number 6, of course, but to a tile value of $1F.

![image2](images\image2.png)

This is speculation on my part, but I think perhaps all of these numbers used to be in the range of $10 to $1F. That would have put 9 at $1F. If that’s the case, limiting the number of lives remaining to $1F would make sense. Graphics changes were likely made, and this value was never updated. $1F was no longer the tile ID For 9 but rather the tile ID for 6. So… Here is a Game Genie code to increase maximum lives in reserve to 9 - Tile ID $22 hex. !

![image3](images\image3.png)

Now for the main event - Why is platforming in this game so difficult? We begin with the word “jump.” The start of a jump in this game is inconsistent. Jumping in place has a wind-up. You bend your knees before you jump - just as you would in real life, I hope. Unfortunately, an attempt at realistic animation like this creates a substantial delay between a button press and leave the ground. So we have perceived input delay even though we are simply waiting on animation. You could argue that this is a design decision. The game isn’t trying to be Mega Man, and players just have to get used to that intentional delay. Now if you jump while running, the jump begins immediately… also kinda like it would in real life. Maybe these jumps are more realistic in a way, but the discrepancy is frustrating. Now… there is no fate but what we make for ourselves. Therefore… every game is a sandbox game when you can reprogram it. Let’s get into this code. This is the logic sequence executed once a valid jump action has been detected.

![image4](images\image4.png)

It starts the jump. This is the crouch animation option. Following that is the jump immediately option. There is a check above these two sections that determines which of them is executed. If the player has any X velocity present or they are currently on a ladder, it skips ahead to the code used for jumping immediately. If no x velocity or ladder status is detected, code execution simply continues and sets the player’s state to “pre-jump.” There are two additional checks internal to this subroutine that govern the results we see. First is a flag that indicates if the player can jump or not. If it is set, the jump can begin, otherwise, the entire sequence is skipped. If this flag did not exist in this code, well… forget double jump. It would be more like an infinite jump. You could jump almost whenever you wanted\! The second check is the Player State. This is used for our ladder check criteria, but it is also assigned a value within this logic depending on if we do or do not have a pre-jump. Actions such as standing, running, ducking, or even being in mid-jump have a value of 0\. 

![image5](images\image5.png)

Call it “neutral.” Examples of different player states include kneeling in order to fire, holding down the A button to throw an object a short or long distance, or climbing a ladder.

![image6](images\image6.png) 

Input is handled in different ways versus standard movement when the player is in these states. The state is important for transitions. 8 is used to indicate a pre-jump sequence. 9 is used when landing.

![image7](images\image7.png) 

These states require a few frames of animation before moving to the next state - likely a return to a neutral state. The transition from landing to neutral in particular can result in a perfect storm of failure, and we will dive into that shortly. Another value maintained in RAM contains bits that indicate if the player is landing, airborne, falling - as in they fell off a platform vs jumped somewhere, or can’t move left or right thanks to an obstacle.

![image8](images\image8.png) 

Now as for why platforming is so difficult in The Terminator, I know of at least three reasons.

The first is the standing jump versus the running jump. This may seem minor - once you know a running jump starts immediately, just make sure you always press left or right before you jump. This could be a good approach to starting a jump from a standstill, but what if you want to bunnyhop up several platforms like those found in the very first screen of the game? Landing not only starts an animation, it also zeroes out X velocity. So if you get a running start, jump immediately, hit the first platform, and press jump again to go to the second platform, you will stop and enter a crouch animation before that second jump takes off even though you are still holding right. Let’s just get rid of the pre-jump sequence. How about we leave the skip ahead logic here for a running jump and make a small modification here - at the end of the pre-jump setup logic? Instead of skipping to Bank Switch to Jump Graphics, we will skip to Start Running Jump - the area directly beneath it. One Game Genie code will do it. All of the modified values within the pre-jump code we just executed will be overwritten with running jump values no matter what. That makes the platforming a lot easier than it was. Easier, perhaps, but not “easy.” I know you don’t want additional problems, but oh, we certainly have them. In order to land on a platform, you need to check for environmental collision detection. Here is a platform. Here is the player. Seems like the width of the player sprites would dictate the area where this entity would collide with the platform, but no. Platforming checks in The Terminator are performed using… one pixel. 

![image9](images\image9.png)

The integer pair that represents the player’s X and Y position is the only coordinate used for platform collision. No entity width is established. This creates multiple problems. The most obvious is that there is no forgiveness when it comes to the edges of platforms. Either you are standing on them or not.

![image10](images\image1.png)

It is extremely easy to undershoot or overshoot smaller platforms. And on the subject of running jumps, it may feel like you pressed jump in time to launch from a platform… but in reality you fell off the platform before the jump button was pressed. As soon as you reach this position, jumping is no longer an option. That may not even be the most frustrating issue with collisions in platforming. Sometimes a jump may appear to end and start a landing for a brief moment only to then change its mind and let the player fall through the ground. Why does this happen? The game examines where you are going to be rather than where you are when it comes to determining if you are going to land on a platform. This is accomplished by using temporary values to hold the results from applying the X and Y velocities to the X and Y positions respectively. Using the resulting coordinates allows environmental collision to “look toward the future” and determine if you are going to land or not. Maybe it seems like a good idea, but the problem is there is other logic that can alter these values in between each of these checks. The checks are performed early in the frame - about here. The code that actually updates player position using velocity happens at the very END of the frame. That’s a lot of time to destroy that early prediction. What are some examples of what can happen during this time? As we know, landing zeroes out X velocity. Lateral movement involves acceleration and deceleration. You accelerate while holding the d-pad and decelerate when you let go or change direction, for example - another X Velocity change. Gravity is applied to Y velocity at some point. Let’s set up the console log in the emulator so we can monitor the position and velocity values in a situation where we appear to land but actually fall through the ground. We can see what happens\! The goal is to reach this column of pixels - achieve an X coordinate of 240\. Column 240 and the area to the left are considered ground, and we land. Column 241 and this area to the right mean uhh… terminated. So we follow the journey of a single pixel. I have a save state for a landing failure, and this is where we will begin - after a single frame has completed its logic. We are traveling to the left and therefore have a negative velocity. We have also released the directional pad on the controller, and the X velocity is decelerating. Current speed is three quarters of a pixel per frame. Downward velocity thanks to gravity is 1.875 pixels per frame. Notice our X Position here is 242.875. We need the integer part of this to reach 240 in order to land. All of these numbers are what the Ground and gravity subroutine sees when calculating a prediction. It applies the current horizontal and vertical velocity to find out where it thinks we should be by the end of the frame. It only cares about integers and thinks we will end up at X:242 and Y:176. We can’t land there, and execution continues. Y Velocity is increased thanks to acceleration due to gravity. The X Velocity is adjusted + 1/8th of a pixel because our leftward movement is decelerating. So when the frame is complete, our new position is NOT where the game thought we would be. That said, the results are inconsequential. Let’s move on. Things continue to function in the same way for each frame, and then we reach Frame 5 of our example - and this is it. Ground and Gravity applies velocity and sees that we’ve reached 240\. Hey\! That’s our goal. We should make it as far left as we need to in order to land on solid ground. So the subroutine does a ground object check using these destination coordinates and finds ground below that is within range. Naturally, logic shortly after that decides it is time to land. So… It eliminates the fractional part of the player’s Y location and removes all Y Velocity. As the landing logic kicks in, X velocities are also erased. But then we get to the end of the frame where we actually apply our velocities, and well… now we do NOT have what we need to reach X coordinate 240\. Our X coordinate falls short of reaching column 240 because we have no X Velocity, and we therefore do not have solid ground beneath us afterall. If you look at the graphics, our player’s location is indeed one pixel away from being where it needs to be - behind that vertical line that marks horizontal coordinate 240\. The earlier subroutine performed the logic necessary to initiate a landing and so we look like we ARE landing, but then we fall through the ground. Too late to move one more pixel left now\! We missed the platform. What is rather funny here is that the game really WAS under the assumption you landed for just a few frames. The game puts us in a Landing State, flips the landing status bit to ON, and even says we can jump now\! Until our state rolls from landing back to neutral, the game lets us jump\! Gravity is already starting to push us downward again as there is no ground to stand upon, but we can press the jump button to jump from midair AND… nudge left on the d-pad to land. A second chance. So spamming the jump button just in case you don’t make it will let you make a lateral course correction to ensure that you do. Remember - It only works if the game thinks you landed at some point thanks to X velocity during ground checks. This fall, for example, is inevitable. You’ve heard about performing a frame-perfect action, but what about a frame-perfect failure? When you land and enter a state of... landing, you have the option to jump immediately. The game will read your input and roll you into a standing jump. Unfortunately, the way that the input handler works will IGNORE your input if you press it at just the right (as in wrong) time. The code is very relevant here as the problem lies in a perfect storm of timing. Some code has been summarized inside brackets for the sake of readability. The game passes through this action handler each frame and the logic executes a to-do list based on the player’s current state. The state’s associated list contains possible player actions based on the controller’s state and are ordered by priority. Here is the basic rundown: It reads the current state of the player and uses it to find the base address pointer to all of the to-do list items for that player state. Each to-do list item is made up of five bytes. The first contains the bits to use to filter for a controller press. So if the player pressed B to jump, the controller press value in RAM would have this bit set. This binary value in hexadecimal is $40. Therefore a to-do list item checking for a jump would filter for this bit by using a value of $40 hex. The second byte is set to zero to see if the button IS pressed and set to 1 to see if the button is NOT pressed. The third byte is used as part of filtering for the NOT pressed logic. The last two bytes contain the ROM location to jump to in order to process that particular action. The address is in order from low byte to high byte. Processing Jump for example takes us to address $ED05. Encountering a value of $FF signals the end of the list. Let’s return to the processing logic. It reads the player’s input and hangs on to it. We start to loop through these to-do list items in order. If an action needs to be performed due to input or lack of input, the logic will jump to where it needs to in code, perform appropriate logic, and return here to continue looping through other actions until all to-do list items associated with the current state have been checked. However if the logic altered the player’s state thanks to processing one of these actions, the remainder of the action checks in the to-do list are now considered irrelevant, and logic will break out of the loop so it does not process those remaining checks. In our example here, we have been reviewing the neutral to-do list. As you stand there, it runs through this list each frame in this order. By the way - the first item in the list checks to see if the player is pressing left or right. The second item in the list checks to see if the player is NOT pressing left or right. Why would you care to check if they were NOT pressing left or right? If you press a direction, logic will increase your velocity in that direction. If you let go of that direction, logic still has to move you as you decelerate. Not pressing a direction can result in movement just like pressing a direction. Each option must be checked, but only one is applicable for the current frame. You are either pressing a direction or not. Now what about landing? Here comes our needle in the haystack of failure. Landing is, as you know, a different player state: A value of 9. That changes the base address for our “Todo list.” That in mind, here is the landing to do list for each frame in which the player is in a landing state. There are only three items: 1: Has the Player Landed? This is a forced check independent of controller input. The logic sets the player state back to neutral once the appropriate moment is reached. 2: Did they press B to jump? As we know, you can start a jump throughout the landing cycle… except during one frame. 3: Did they press Select? Because I guess you can change weapons at almost any time. The game rolls through this to-do list each frame while in a landing state. When the appropriate frame of landing is reached, the handler sees the player has landed while handling Item #1. It changes the player state to neutral, returns to the handler, and then bails from the loop thanks to a state change. Again - It does NOT process player input for jump or select on this frame. On the very next frame, the handler returns to using the neutral to-do list. So what could go wrong? “I pressed the button\! It just didn’t work\!” is a perfectly accurate phrase to describe what happens… or rather didn’t happen… in the following scenario: If the player is landing and presses jump on the frame before the game detects the end of the landing cycle, the next Item 1 logic sees that they landed and performs a player state change to neutral as expected. The problem is that that breaks us out of the action handler loop and skips processing the jump button press that just happened. The very next frame processes the neutral state, and checks to see what buttons are pressed. The player may STILL be holding the jump button but since the jump button was not JUST pressed, the game continues to ignore it. The game’s design works under the assumption that we already handled this jump input in a previous frame. In reality, we skipped it. Is there anything we can do to make the game still process the jump button instead of ignoring it on that “bad luck frame” at the end of the landing sequence? I suggest we reprioritize the Landing to-do list. Move jump input handling up to the top spot, and slide the state change check into the second spot. Five bytes in the ROM are used per to-do list item, and both sets of bytes need to be changed. Some bytes are identical between the two and don’t need a change. That leaves six bytes that need to be changed in order to effectively “swap” item priority. If the whole point of the “Landed” check is to simply change the player state from 9 (Landing) to 0 (Neutral) and abort the rest of the handler, that logic should still function properly with the reprioritized list. Here are the scenarios: Number 1: The jump routine is called first, sees no jump button was pressed, returns to the handler loop, and the Landed Item logic still works as usual. It is just executed after the jump check now. It may or may not cancel the remainder of the to-do list based on where we are in the landing cycle. Number 2: The jump routine is called, the jump button is pressed, and either a standing jump or a running jump are executed. Either one of these would still accomplish the same task of changing the Player state from landing to neutral or landing to pre-jump, which is ALL the “land-ED” function is supposed to do - move us to the next state. When this happens, the handler sees the state change and bails, which is, once again, all that the Landed operation was supposed to do anyway. As far as using Game Genie codes to make the change, well… it is going to take six codes to swap the bytes. You can’t fit that into a single Game Genie… although perhaps you could daisy chain multiple Game Genies... Combine these six codes with the single code fix for the running jump, and now you have a noticeable improvement in your platforming abilities. The animation for landing combined with the zeroing of x velocity is still a bit jarring, and of course the single pixel environmental collision detection may still give you problems… but try these changes out\! See if they make a difference. OK. That’s enough of Terminator for now. Let me know if I should... be back... for a second video. Like, subscribe, and leave a comment for more videos like this one. I also have a Patreon available if you are interested, and thanks for watching.

## **References**

1. [Why is Platforming so Difficult in The Terminator for NES? - Behind the Code](https://www.youtube.com/watch?v=QuPTCoTUnJ0&t=6s)  
2. 