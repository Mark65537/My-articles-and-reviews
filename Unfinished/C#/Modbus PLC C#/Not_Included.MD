
# Как я пытался считать переменные с ПЛК с помощью Modbus, чтобы потом вывести в приложение на C#

**О чем эта статья:**

## Введение

Modbus — это открытый протокол связи, широко используемый в промышленной автоматизации для обмена данными между устройствами. Протокол работает по принципу "мастер-слейв" (master-slave), где мастер запрашивает данные у подчиненных устройств (слейвов).

для работы с Modbus в среде CODESYS и чтения переменных ПЛК (программируемого логического контроллера) в приложение на C#.

Основная цель — показать архитектуру, а не просто «как вызвать ReadHoldingRegisters».

Modbus — это протокол по адресам (coil / discrete input / holding register / input register)

Это самый прямой и простой способ: ваше C# приложение может быть Modbus-клиентом, ПЛК — Modbus-сервером (slave).

Для C# есть готовые библиотеки:

[NModbus](https://github.com/NModbus/NModbus) — популярная C# библиотека для Modbus (поддерживает TCP, RTU и UDP).

[FluentModbus](https://github.com/Apollo3zehn/FluentModbus) — .NET Standard библиотека с поддержкой Modbus TCP/RTU.

[csModbusLib](https://libraries.io/nuget/csModbusLib) — ещё одна .NET-библиотека для Modbus.

Коммерческие библиотеки: например, [WSMBT](https://www.modbustools.com/modbus_wsmbt.html) (Modbus Master TCP/IP) для .NET.

В C# приложении вы создаёте Modbus TCP-клиент, подключаетесь к IP ПЛК, указываете нужный Unit ID (адрес slave), потом читаешь регистры Holding или Input (в зависимости, где у вас хранятся переменные).

в modbus нельзя считать переменную по имени, только по номеру регистра, так же НЕТ поддержки событий.

разница между Holding и Input Register

**Input** только чтение
**Holding** чтение/запись

Важно: если не обновляются регитры в CODESYS нужно внизу справа измени **always updete variables** с **use parent device setting** на **Enabled 2 (always in bus cycle task)**

Я пытался считать переменные используя CODESYS. были и другие способы чтения переменных наше устройство поддерживало MQTT, Ethernet/IP, OPC Ua, Modbus RTU и тд. Если интересует полный список и почему вы выбрали именно Modbus TCP, можете посмотреть здесь.

потому что нам не нужна была привязка к от сису так так как мы будем устанавливать наша программное обеспечение на другие машины

Если интересно поразбираться как можно реализовать это через питоновский скрипты могу посоветовать проект Робин. 

С зернед IP я не помню почему не заработал

В общем мат бас был единственным способом который заработал с первого раза без дополнительной установки чего-либо

Был Ещё вариант написать свой кастомный протокол но мы это отложили на последнюю очередь потому что будет сложность в его поддержке а также нужно будет помимо c# писать сервер пэлкашной части что я не очень умею

Я не буду углубляться в реализацию плк части так как это выходит за рамки данной статьи здесь мы будем больше говорить про взаимодействие его с макбасом

## Структура данных

Структура данных организована следующим образом:

todo добавить что заголовок нужен чтобы определять что это за проект, так как на ПЛК может заливаться несколько проектов

- **Первые 2 регистра** — заголовок устройства (тип устройства и версия)
- **Остальные регистры** — значения переменных

Имена переменных и метаданные не хранятся в ПЛК — они жестко прописаны в карте переменных на стороне C# приложения. Карта переменных — это отдельный класс, содержащий описания всех переменных с их адресами, типами и размерами.

### Заголовок

На первом этапе он задумывался как простая структура данных, однако на практике этого оказалось недостаточно. Со временем стало очевидно, что заголовок должен быть оформлен в виде класса — это заставляет пользователя заполнять все необходимые поля, без которых сам заголовок теряет смысл.

заголовок нужен чтобы определять что это за проект, так как на ПЛК может заливаться несколько проектов
изначаально идея была что заголовок это простая структура с полями тип проекта и версия, но со временем стало понятно что нужен класс, что бы была возможность его контролировать.

размер заголовка всегда фиксированный

| Offset from | Offset to | Size | Note                                           |
|-------------|-----------|------|------------------------------------------------|
| 0           | 1         | 1    | тип проекта. например ВФУ |
| 1           | 1         | 1    | версия проекта                    |

## Особенности Modbus

- **Регистры**: Modbus работает с регистрами — 16-битными ячейками памяти
- **Типы регистров**: Holding Registers (функция 03), Input Registers (функция 04), Coils, Discrete Inputs
- **TCP/IP**: В нашем случае используется Modbus TCP/IP, работающий поверх TCP соединения
- **Адресация**: Каждое устройство имеет уникальный Slave ID

За раз можно читать 125 регистров.
один регистр это 2 байта.
Если для Modbus Server используете Modbus Slave, то нужно начинать читать регистры с 10 адреса. Не знаю чья это особенность протокола или программы.

## Особенности работы в Modbus

- Всего доступных регистров в CODESYS = 4096.
- если в CODESYS замапить переменную в holding register то при запуске ПЛК он их обнуляет.
- если в регистр засунуть имя массива то в регистре будет только первый элемент. другие переменные будут тоже обрезаться.
- строки в регистре сохраняются в обратном порядке.
- чтобы не делить значения переменных чей тип больше 16 бит, можно использовать один массив в который будут собираться все значения.

## Где и почему используют Modbus

- Кассы
- учет погоды
- другая передача данных

его используют так как он экономичней и его легче внерить

## Варианты получения значений переменных

 - [-] OPC UA
 - [] Modbus TCP
 - [-] Modbus RTU
 - [-] CANopen
 - [-] EtherCAT
 - [] EtherNet/IP
 - [] MQTT
 - [-] PLCHandler
 - [-] Shared memory
 - [] Кастомный TCP сервер на ПЛК
 - [?] IECVarAccessBrowsingProxy

## Почему другие способы не подходят

### Ethernet/IP

на C# НЕ существует ни одной полноценной библиотеки, которая позволяет создать EtherNet/IP Adapter (сервер), скорей всего это из за того что этот протокол на риалтайм, а насколько я понял на C# очень сложно или почти не возможно сделать поддержку риалтайм.
так же нет ни одной нормальной программы для тестирования, чтоб можно было проверить работы твоей программы.
непонятно как с этим работать в CODESYS, там вроде есть подходящии устройства но как будто функционал обрезан.

### MQTT

непонятно как с этим работать в CODESYS, там вроде есть подходящая библиотека, но к ней нет внятной документации.
Эксперементы с данной библиотекой никчему не привели.

MQTT у нас не получилось потому что единственное бесплатная библиотека которая нам была доступна была без внятной документации мы поэкспериментировали на ней но ничего добиться не смогли

### PLCHandler

эта штука платная и как ее оплатить непонятно. Вроде как если скачаешь определенню версию CODESYS то она идет в комплекте

### Python-скрипты CODESYS

Ещё был способ взаимодействия через Python-скрипты CODESYS, но мы подумали что это самый последний способ он самый замороченный и даже не стали его пробовать.

## Работа с Modbus в CODESYS

```st
AT %IW
AT %QW
AT %MW
```

## Работа с байтами

В отличие от чтения файлов, где структура данных фиксирована, при работе с Modbus:

- Заголовок и структура данных могут меняться в зависимости от версии протокола
- Адреса переменных могут отличаться для разных типов устройств
- Если вы хотите обращаться к элементам через точку (например, `data.Temperature`), лучше использовать класс карты переменных с типизированными свойствами

**Пример типизированного доступа:**

```csharp
public class MyVarMap
{
    public PlcValue<float> Temperature { get; set; }
    public PlcValue<ushort> Status { get; set; }
}

// Использование
var data = reader.ReadAll(slaveId);
float temp = (float)data.PlcValues
    .First(v => v.Name == "Temperature")
    .Value;
```

## Схема данных

сначало идет заголовок, потом данные в сыром виде.

### Заголовок

заголовок нужен чтобы определять что это за проект, так как на ПЛК может заливаться несколько проектов
изначаально  идея была что загголовок это простая структура с полями тип проекта и версия, но со временем стало понятно что нужен класс, что бы была возможность его контролировать.

размер заголовка всегда фиксированный

| Offset from | Offset to | Size | Note                                           |
|-------------|-----------|------|------------------------------------------------|
| 0           | 1         | 1    | тип проекта. например ВФУ |
| 1           | 1         | 1    | версия проекта                    |

### Значения переменных

здесь храняться данные в сыром виде без разделителя. Единственно у строк будет терминальный символ.
все остальные данные о переменных храняться в коде.

### Класс PlcValue

Самая простая реализация класса для представления переменной ПЛК:

```cs
public class PlcValue<T> : IEquatable<PlcValue<T>>
{
    private static readonly HashSet<string> _usedNames = new();

    public PlcValue(string name, T value, ushort address)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Имя не может быть пустым", nameof(name));

        // Проверяем уникальность нового имени
        if (_usedNames.Contains(name))
            throw new ArgumentException($"Имя \"{name}\" уже используется.", nameof(name));

        _usedNames.Add(name);
        Name = name;
        Value = value!;
        Address = address;

        RegSize = CalculateRegSize(typeof(T));
        ByteSize = (UInt32)RegSize * 2;
    }
    public PlcValue(string name, T value, ushort address, ushort regSize)
        : this(name, value, address)
    {
        RegSize = regSize;
        ByteSize = (UInt32)RegSize * 2;
    }
    /// <summary>
    /// Имя переменной. Уникальное среди всех экземпляров PlcValue.
    /// Не может быть null или пустой строкой.
    /// </summary>
    public string Name { get; }
    /// <summary>
    /// Значение
    /// </summary>
    public T Value { get; }
    /// <summary>
    /// Тип. НЕ null
    /// </summary>
    public Type CSType => typeof(T);
    /// <summary>
    /// Номер регистра. По умолчанию с 0
    /// </summary>
    public UInt16 Address { get; }
    /// <summary>
    /// Размер в байтах. Если не задан, вычисляется автоматически на основе типа.
    /// </summary>
    public UInt32 ByteSize { get; }
    /// <summary>
    /// Размер в регистрах. Если не задан, вычисляется автоматически на основе типа.
    /// </summary>
    public UInt16 RegSize { get; }

    public bool Equals(PlcValue<T>? other)
    {
        if (other is null)
            return false;

        if (ReferenceEquals(Value, other.Value))
            return true;

        if (Value is Array a1 && other.Value is Array a2)
            return a1.Length == a2.Length &&
                   a1.Cast<object>().SequenceEqual(a2.Cast<object>());

        return EqualityComparer<T>.Default.Equals(Value, other.Value);
    }

    public override bool Equals(object? obj)
        => obj is PlcValue<T> other && Equals(other);

    public override int GetHashCode()
        => HashCode.Combine(Name, Value, CSType, Address);

    public static bool operator ==(PlcValue<T>? left, PlcValue<T>? right)
        => object.Equals(left, right);

    public static bool operator !=(PlcValue<T>? left, PlcValue<T>? right)
        => !object.Equals(left, right);

    /// <summary>
    /// Вычисляет размер в регистрах на основе типа.
    /// </summary>
    private static ushort CalculateRegSize(Type type)
    {
        if (type.IsEnum)
            type = Enum.GetUnderlyingType(type);

        return Type.GetTypeCode(type) switch
        {
            TypeCode.Boolean or
            TypeCode.Byte or
            TypeCode.SByte or
            TypeCode.Int16 or
            TypeCode.UInt16 => 1,

            TypeCode.Int32 or
            TypeCode.UInt32 or
            TypeCode.Single or
            TypeCode.DateTime => 2,

            TypeCode.Int64 or
            TypeCode.UInt64 or
            TypeCode.Double => 4,

            _ => 1 // массивы, строки — задаются вручную
        };
    }
}
```

если хотите добавлять его в массив то используйте интерфейс IPlcValue

```cs
public interface IPlcValue
{
    /// <summary>
    /// Имя переменной. Уникальное среди всех экземпляров PlcValue.
    /// Не может быть null или пустой строкой.
    /// </summary>
    public string Name { get; }
    /// <summary>
    /// Тип. НЕ null
    /// </summary>
    public Type CSType { get; }
    /// <summary>
    /// Номер регистра. По умолчанию с 0
    /// </summary>
    public UInt16 Address { get; }
    /// <summary>
    /// Размер в регистрах. Если не задан, вычисляется автоматически на основе типа.
    /// </summary>
    public UInt16 RegSize { get; }
}
```

если у вас в рантайме будут изменяться значения переменных, то вам нужно будет реализовать интерфейс INotifyPropertyChanged или добавить библиотеку CommunityToolkit.Mvvm. но я бы вам не советовал ее добавлять потому что потом может возникнуть ошибка несоответствия версий библиотеки, так называемый dll-ад, если вы вдруг добавите ее в свой проект. То есть вам надо постоянно помнить что CommunityToolkit.Mvvm содержиться в моей библотеки. поэтому я бы советовал вам реализовать интерфейс INotifyPropertyChanged.

## Чтение данных

### Вариант 1: Раздельные функции

- Третья функция-обертка, которая вызывает обе функции для удобного использования

### функция чтения всех регистров

ReadAll

```cs
public class MemoryRange
{
    public ushort StartAdr { get; }
    public ushort EndAdr { get; }
    public ushort Count { get; }

    public MemoryRange(ushort startAdr, ushort count)
    {
        if (count == 0)
            throw new ArgumentException("Count must be > 0");

        StartAdr = startAdr;
        EndAdr = (UInt16)(startAdr + count - 1);
        Count = count;
    }
}
```

## Marshal и PlcValue

так как у нас переменные считываются не сразу а карта переменных изместна заранее то инициализация переменных происходит в 2 этанпа.Сначала инициализация в карте, потом считывание всех значений, поэтому value может быть null
Так сделано чтобы запрос считывание всех регистров сделать один раз и не нагружать ПЛК.

если не хочешь чтобы Маршал возвращал object то можно сделать так

```cs
public static class ModbusValueMarshaler
{
    public static T Marshal<T>(ushort[] regs)
    {
        // Примеры
        if (typeof(T) == typeof(int))
            return (T)(object)((regs[0] << 16) | regs[1]);

        if (typeof(T) == typeof(float))
            return (T)(object)BitConverter.ToSingle(
                BitConverter.GetBytes(
                    (uint)((regs[0] << 16) | regs[1])
                ), 0);

        throw new NotSupportedException(typeof(T).FullName);
    }
}
```

и использовать

```cs
foreach (var template in templates)
{
    ushort[] slice = ReadSlice(...);

    object value = template switch
    {
        PlcValue<int> v    => ModbusValueMarshaler.Marshal<int>(slice),
        PlcValue<float> v  => ModbusValueMarshaler.Marshal<float>(slice),
        PlcValue<bool> v   => ModbusValueMarshaler.Marshal<bool>(slice),
        _ => throw new NotSupportedException()
    };
}
```

но это мало что даст так как у value все равно будет тип object

есть еще вариант вставить метод read в PlcValue

```cs
public sealed class PlcValue<T> :
    IPlcValue,
    IEquatable<PlcValue<T>>
{

    public IPlcValue Read(UInt16[] regs)
    {
        T value = ModbusValueMarshaler.Marshal<T>(regs);

        return new PlcValue<T>(
            Name,
            value,
            Address,
            RegSize
        );
    }

}
```

Я считаю что если делать PlcValue<T> то у тебя будет от этого больше проблем чем пользы. Да у тебя тогда идет контроль типов то есть CSType равен типу value, но из за этого тебе нужно создавать лишний интерфейс, а интерфейы я считаю больше зло так как почти всегдаа трудно найти реализацию интерфейса и так же нельзя будет написать типа такого кода

```cs
if (template is PlcValue<T>)
{
    template.Value = ModbusValueMarshaler.Marshal(slice, template.CSType);
}
```

контроль одинаковых имен вставляет палки в коллеса при тестироваании. Нельзя просто копировать функцию из тестов и просто изменить значения которые тебе надо протестировать, нужно еще и изменить имена на уникальные. Возможно еще нельзя копировать значения в новый массив например:

```cs
PlcValue[] result = new PlcValue[countVars];
for (int i = 0; i < countVars; i++)
{
    PlcValue t = vars[i];

    result[i] = new PlcValue(t.Name, value, t.CSType, t.Address);
}
```

### Маршаллинг

не понятно что делать со структурой так как нельзя написать `typeof(struct)`

## Идеальные условия для PlcValue

- обязательно должны быть свойства

```cs
public interface IPlcValue
{
    /// <summary>
    /// Имя переменной. Уникальное среди всех экземпляров PlcValue.
    /// Не может быть null или пустой строкой.
    /// </summary>
    public string Name { get; }
    /// <summary>
    /// Тип. НЕ null
    /// </summary>
    public Type CSType { get; }
    /// <summary>
    /// Номер регистра. По умолчанию с 0
    /// </summary>
    public UInt16 Address { get; }
    /// <summary>
    /// Размер в регистрах. Если не задан, вычисляется автоматически на основе типа.
    /// </summary>
    public UInt16 RegSize { get; }
}```

- PlcValue должен быть

```cs
public class PlcValue<T> : IEquatable<PlcValue<T>>, IPlcValue

в PlcValue должны быть конструкторы


public PlcValue(string name, T value, ushort address)

public PlcValue(string name, ushort address)

public PlcValue(string name, T value, ushort address, UInt16 regSize)

public PlcValue(string name, T value, UInt16 address, UInt32 ByteSize)
```

- маршалинг вот такой

```cs
<тип из PlcValue> value = ModbusValueMarshaler.Marshal(<какие то аргументы>);
```

- контроль имени переменной. У каждой переменной должно быть уникальное имя
- контроль типов. Тип у value должен быть такой же как type.
- Не использовать рефлексию

## Оптимизация для измененных значений ПЛК-переменных

UI←----------ViewModel←------------------------Task←--------------ModBus Server
DataTable←---ObservableCollection<PlcValue>←---DataRead←----------Registers
    ↑--------Dictionary<string, PlcValue>←-----ChangedPlcValues←-----↓


1. на каждую переменную повесить событие

2. добавить событие которое передает только измененные ПЛК-переменные

3. узнавать какие переменные были изменены в таблице и брать только их значения

Можно конечно сравнивать значения(PlcValue.Value) но это не оптимально. проще сравнивать регистры.

Мы не можем запихать в функцию цикла обновления условие, в котором будет проверка считать все переменные или считать только изменённые переменные Поэтому лучше всего сделать одну функцию чтения переменных в том числе заголовка в ней сначала будет идти функция которая просто вернёт нам все необходимые регистры потом будет идти функция которая вернёт нам обработает все регистры и вернёт нам схему после этого уже будет идти функция которая вернёт список только изменённых переменных если эта функция вернула пустой список то не возникает событие изменение переменных в противном случае оно возникает И после этого Идёт уже всегда события чтение всех переменных

Нужно сделать возможность чтобы я с любого места программы мог считать все регистры и переделать их в переменные Желательно это делать каждый раз переподключении и при первой инициализации подключения

Есть идея изменить конструктор taska чтобы он принимал в качестве аргументов некие сервисы. Например:

```cs
ctor(MBSettings settings, object _varmap, Reader или Writer)
```

Выяснилось пренеприятнейшее известие оказывается если сделать в структуре конструктор то его не обязательно вызывать при инициализации Можно также инициализировать просто Поля структуру из-за этого структура кажется ещё менее бесполезными практики использования языка C#.

## Вывод

Создание библиотеки для работы с Modbus в C# требует решения нескольких задач:

1. **Структурирование данных**: Определение карты переменных с метаданными (адреса, типы, размеры)
2. **Эффективное чтение**: Минимизация количества Modbus-запросов через группировку регистров
3. **Преобразование типов**: Маршаллинг между регистрами Modbus и типами C#
4. **Управление соединением**: Автоматическое переподключение и мониторинг состояния
5. **Оптимизация записи**: Запись только измененных переменных для снижения нагрузки

### Ключевые решения

- ✅ Использование единого запроса для чтения всех данных
- ✅ Типизированная карта переменных через класс `PlcValue<T>`
- ✅ Централизованный маршаллер для преобразования типов
- ✅ Автоматическое управление переподключением через `ModbusReconnectionTask`
- ✅ Событийная модель для уведомления об изменениях

### Результат

Получилась удобная которая:

- Абстрагирует низкоуровневые детали работы с Modbus
- Предоставляет типизированный API для работы с переменными ПЛК
- Автоматически управляет соединением и переподключением
- Оптимизирует производительность через минимизацию запросов